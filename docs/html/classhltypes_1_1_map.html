<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C++ High Level Types: hltypes::Map&lt; K, V &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C++ High Level Types
   </div>
   <div id="projectbrief">This library provides commonly used high level types and methods for easier and better coding.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>hltypes</b></li><li class="navelem"><a class="el" href="classhltypes_1_1_map.html">Map</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classhltypes_1_1_map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hltypes::Map&lt; K, V &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulates std::map and adds high level methods.  
 <a href="classhltypes_1_1_map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="hmap_8h_source.html">hmap.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for hltypes::Map&lt; K, V &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classhltypes_1_1_map.png" usemap="#hltypes::Map_3C_20K_2C_20V_20_3E_map" alt=""/>
  <map id="hltypes::Map_3C_20K_2C_20V_20_3E_map" name="hltypes::Map_3C_20K_2C_20V_20_3E_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a678963c35deca835dbee0a182759e2a1"><td class="memItemLeft" align="right" valign="top"><a id="a678963c35deca835dbee0a182759e2a1"></a>
typedef std::map&lt; K, V &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a678963c35deca835dbee0a182759e2a1">iterator_t</a></td></tr>
<tr class="memdesc:a678963c35deca835dbee0a182759e2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type exposure. <br /></td></tr>
<tr class="separator:a678963c35deca835dbee0a182759e2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a57136c1a6cc1d51814b219584331a"><td class="memItemLeft" align="right" valign="top"><a id="a12a57136c1a6cc1d51814b219584331a"></a>
typedef std::map&lt; K, V &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a12a57136c1a6cc1d51814b219584331a">const_iterator_t</a></td></tr>
<tr class="memdesc:a12a57136c1a6cc1d51814b219584331a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type exposure. <br /></td></tr>
<tr class="separator:a12a57136c1a6cc1d51814b219584331a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cd5ceed9d307b48cc19e029ee66006"><td class="memItemLeft" align="right" valign="top"><a id="a31cd5ceed9d307b48cc19e029ee66006"></a>
typedef std::vector&lt; K &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a31cd5ceed9d307b48cc19e029ee66006">kiterator_t</a></td></tr>
<tr class="memdesc:a31cd5ceed9d307b48cc19e029ee66006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type exposure. <br /></td></tr>
<tr class="separator:a31cd5ceed9d307b48cc19e029ee66006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bf325b279b5a92a0b0aecd637a6291"><td class="memItemLeft" align="right" valign="top"><a id="a54bf325b279b5a92a0b0aecd637a6291"></a>
typedef std::vector&lt; K &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a54bf325b279b5a92a0b0aecd637a6291">const_kiterator_t</a></td></tr>
<tr class="memdesc:a54bf325b279b5a92a0b0aecd637a6291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type exposure. <br /></td></tr>
<tr class="separator:a54bf325b279b5a92a0b0aecd637a6291"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a38ca7d0a892d3111abe7d0db66470284"><td class="memItemLeft" align="right" valign="top"><a id="a38ca7d0a892d3111abe7d0db66470284"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a38ca7d0a892d3111abe7d0db66470284">Map</a> ()</td></tr>
<tr class="memdesc:a38ca7d0a892d3111abe7d0db66470284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor. <br /></td></tr>
<tr class="separator:a38ca7d0a892d3111abe7d0db66470284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9734443a4728f65a1dba47a5e57a1cba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a9734443a4728f65a1dba47a5e57a1cba">Map</a> (const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;other)</td></tr>
<tr class="memdesc:a9734443a4728f65a1dba47a5e57a1cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a9734443a4728f65a1dba47a5e57a1cba">More...</a><br /></td></tr>
<tr class="separator:a9734443a4728f65a1dba47a5e57a1cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae655dda4f50b5a9cbb80d37a1d6b71f6"><td class="memItemLeft" align="right" valign="top"><a id="ae655dda4f50b5a9cbb80d37a1d6b71f6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ae655dda4f50b5a9cbb80d37a1d6b71f6">~Map</a> ()</td></tr>
<tr class="memdesc:ae655dda4f50b5a9cbb80d37a1d6b71f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ae655dda4f50b5a9cbb80d37a1d6b71f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f856ce764decaee35b82100aa61302"><td class="memItemLeft" align="right" valign="top">V &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a44f856ce764decaee35b82100aa61302">operator[]</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a44f856ce764decaee35b82100aa61302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns value with specified key.  <a href="#a44f856ce764decaee35b82100aa61302">More...</a><br /></td></tr>
<tr class="separator:a44f856ce764decaee35b82100aa61302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fc080e73d7eebcf7e523c51d1d7d0d"><td class="memItemLeft" align="right" valign="top">K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ad7fc080e73d7eebcf7e523c51d1d7d0d">operator()</a> (const V &amp;value) const</td></tr>
<tr class="memdesc:ad7fc080e73d7eebcf7e523c51d1d7d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as key_of.  <a href="#ad7fc080e73d7eebcf7e523c51d1d7d0d">More...</a><br /></td></tr>
<tr class="separator:ad7fc080e73d7eebcf7e523c51d1d7d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ace1c4a7f7c12acbe886dddb1ca4f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a27ace1c4a7f7c12acbe886dddb1ca4f3">operator==</a> (const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;other) const</td></tr>
<tr class="memdesc:a27ace1c4a7f7c12acbe886dddb1ca4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as equals.  <a href="#a27ace1c4a7f7c12acbe886dddb1ca4f3">More...</a><br /></td></tr>
<tr class="separator:a27ace1c4a7f7c12acbe886dddb1ca4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4b4a3e5235eeecd430ef39e94567cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a2b4b4a3e5235eeecd430ef39e94567cd">operator!=</a> (const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;other) const</td></tr>
<tr class="memdesc:a2b4b4a3e5235eeecd430ef39e94567cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as nequals.  <a href="#a2b4b4a3e5235eeecd430ef39e94567cd">More...</a><br /></td></tr>
<tr class="separator:a2b4b4a3e5235eeecd430ef39e94567cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37294bcbb724443f84678a21f3b5e9f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a37294bcbb724443f84678a21f3b5e9f0">size</a> () const</td></tr>
<tr class="memdesc:a37294bcbb724443f84678a21f3b5e9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of values in the <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>.  <a href="#a37294bcbb724443f84678a21f3b5e9f0">More...</a><br /></td></tr>
<tr class="separator:a37294bcbb724443f84678a21f3b5e9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2642cbf87e2920f0e32fe745335535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#aef2642cbf87e2920f0e32fe745335535">keys</a> () const</td></tr>
<tr class="memdesc:aef2642cbf87e2920f0e32fe745335535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all keys.  <a href="#aef2642cbf87e2920f0e32fe745335535">More...</a><br /></td></tr>
<tr class="separator:aef2642cbf87e2920f0e32fe745335535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80a66e7e7ee1839b65ad6d0721e3d6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ac80a66e7e7ee1839b65ad6d0721e3d6f">values</a> () const</td></tr>
<tr class="memdesc:ac80a66e7e7ee1839b65ad6d0721e3d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all values.  <a href="#ac80a66e7e7ee1839b65ad6d0721e3d6f">More...</a><br /></td></tr>
<tr class="separator:ac80a66e7e7ee1839b65ad6d0721e3d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8faec6d2543aab4f077b814775be58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#aca8faec6d2543aab4f077b814775be58">values</a> (const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt; <a class="el" href="classhltypes_1_1_map.html#aef2642cbf87e2920f0e32fe745335535">keys</a>) const</td></tr>
<tr class="memdesc:aca8faec6d2543aab4f077b814775be58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all values in the same order as the given corresponding keys.  <a href="#aca8faec6d2543aab4f077b814775be58">More...</a><br /></td></tr>
<tr class="separator:aca8faec6d2543aab4f077b814775be58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0792aff70ed52424662bb1a3075bdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; std::pair&lt; K, V &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#acd0792aff70ed52424662bb1a3075bdf">keyValuePairs</a> () const</td></tr>
<tr class="memdesc:acd0792aff70ed52424662bb1a3075bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all key-value pairs.  <a href="#acd0792aff70ed52424662bb1a3075bdf">More...</a><br /></td></tr>
<tr class="separator:acd0792aff70ed52424662bb1a3075bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea63d2a46d2d7d63aecd82a66bf15dc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; std::pair&lt; K, V &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#aea63d2a46d2d7d63aecd82a66bf15dc3">keyValuePairs</a> (const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt; <a class="el" href="classhltypes_1_1_map.html#aef2642cbf87e2920f0e32fe745335535">keys</a>) const</td></tr>
<tr class="memdesc:aea63d2a46d2d7d63aecd82a66bf15dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all key-value pairs in the same order as the given corresponding keys.  <a href="#aea63d2a46d2d7d63aecd82a66bf15dc3">More...</a><br /></td></tr>
<tr class="separator:aea63d2a46d2d7d63aecd82a66bf15dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cafe7cd61219c1824cc1bd40cf2984"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ad9cafe7cd61219c1824cc1bd40cf2984">equals</a> (const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;other) const</td></tr>
<tr class="memdesc:ad9cafe7cd61219c1824cc1bd40cf2984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two Maps for being equal.  <a href="#ad9cafe7cd61219c1824cc1bd40cf2984">More...</a><br /></td></tr>
<tr class="separator:ad9cafe7cd61219c1824cc1bd40cf2984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec85d9b8fede42be01cc1daab0ece30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a7ec85d9b8fede42be01cc1daab0ece30">nequals</a> (const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;other) const</td></tr>
<tr class="memdesc:a7ec85d9b8fede42be01cc1daab0ece30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two Maps for being not equal.  <a href="#a7ec85d9b8fede42be01cc1daab0ece30">More...</a><br /></td></tr>
<tr class="separator:a7ec85d9b8fede42be01cc1daab0ece30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69b25f8ab1c89a7785a4a919975ecc1"><td class="memItemLeft" align="right" valign="top">K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#aa69b25f8ab1c89a7785a4a919975ecc1">keyOf</a> (const V &amp;value) const</td></tr>
<tr class="memdesc:aa69b25f8ab1c89a7785a4a919975ecc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns key of specified value.  <a href="#aa69b25f8ab1c89a7785a4a919975ecc1">More...</a><br /></td></tr>
<tr class="separator:aa69b25f8ab1c89a7785a4a919975ecc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a8ad251d2ae43665ea522c08663b73"><td class="memItemLeft" align="right" valign="top">V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ac6a8ad251d2ae43665ea522c08663b73">valueOf</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:ac6a8ad251d2ae43665ea522c08663b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns value of specified key.  <a href="#ac6a8ad251d2ae43665ea522c08663b73">More...</a><br /></td></tr>
<tr class="separator:ac6a8ad251d2ae43665ea522c08663b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522ca637176505439a9578e3e5cd5bbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a522ca637176505439a9578e3e5cd5bbc">hasKey</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:a522ca637176505439a9578e3e5cd5bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of a key.  <a href="#a522ca637176505439a9578e3e5cd5bbc">More...</a><br /></td></tr>
<tr class="separator:a522ca637176505439a9578e3e5cd5bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae603dc45594ba0bc72ed4f71c0e9d91a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ae603dc45594ba0bc72ed4f71c0e9d91a">hasAnyKey</a> (const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt; &amp;<a class="el" href="classhltypes_1_1_map.html#aef2642cbf87e2920f0e32fe745335535">keys</a>) const</td></tr>
<tr class="memdesc:ae603dc45594ba0bc72ed4f71c0e9d91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of a key within an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of keys.  <a href="#ae603dc45594ba0bc72ed4f71c0e9d91a">More...</a><br /></td></tr>
<tr class="separator:ae603dc45594ba0bc72ed4f71c0e9d91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d76235e0053e11869cd761f1d13506"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a92d76235e0053e11869cd761f1d13506">hasAnyKey</a> (const K <a class="el" href="classhltypes_1_1_map.html#aef2642cbf87e2920f0e32fe745335535">keys</a>[], const int count) const</td></tr>
<tr class="memdesc:a92d76235e0053e11869cd761f1d13506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of a key within an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of keys.  <a href="#a92d76235e0053e11869cd761f1d13506">More...</a><br /></td></tr>
<tr class="separator:a92d76235e0053e11869cd761f1d13506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1229db6753b166a6daec52d6564a4f0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a1229db6753b166a6daec52d6564a4f0b">hasAllKeys</a> (const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt; &amp;<a class="el" href="classhltypes_1_1_map.html#aef2642cbf87e2920f0e32fe745335535">keys</a>) const</td></tr>
<tr class="memdesc:a1229db6753b166a6daec52d6564a4f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of all keys.  <a href="#a1229db6753b166a6daec52d6564a4f0b">More...</a><br /></td></tr>
<tr class="separator:a1229db6753b166a6daec52d6564a4f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0c78039113a25701848b6da86aa741"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a6f0c78039113a25701848b6da86aa741">hasAllKeys</a> (const K <a class="el" href="classhltypes_1_1_map.html#aef2642cbf87e2920f0e32fe745335535">keys</a>[], const int count) const</td></tr>
<tr class="memdesc:a6f0c78039113a25701848b6da86aa741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of all keys.  <a href="#a6f0c78039113a25701848b6da86aa741">More...</a><br /></td></tr>
<tr class="separator:a6f0c78039113a25701848b6da86aa741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f4ca01ded32016041040a486b3255c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a21f4ca01ded32016041040a486b3255c">hasValue</a> (const V &amp;value) const</td></tr>
<tr class="memdesc:a21f4ca01ded32016041040a486b3255c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of a value.  <a href="#a21f4ca01ded32016041040a486b3255c">More...</a><br /></td></tr>
<tr class="separator:a21f4ca01ded32016041040a486b3255c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ed4d08538d9d4ea1f7ff05af3984ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a92ed4d08538d9d4ea1f7ff05af3984ba">hasAnyValue</a> (const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; V &gt; &amp;<a class="el" href="classhltypes_1_1_map.html#ac80a66e7e7ee1839b65ad6d0721e3d6f">values</a>) const</td></tr>
<tr class="memdesc:a92ed4d08538d9d4ea1f7ff05af3984ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of a values in an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of values.  <a href="#a92ed4d08538d9d4ea1f7ff05af3984ba">More...</a><br /></td></tr>
<tr class="separator:a92ed4d08538d9d4ea1f7ff05af3984ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d7ee25408c2a85b01b1736303f9044"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a72d7ee25408c2a85b01b1736303f9044">hasAnyValue</a> (const V <a class="el" href="classhltypes_1_1_map.html#ac80a66e7e7ee1839b65ad6d0721e3d6f">values</a>[], const int count) const</td></tr>
<tr class="memdesc:a72d7ee25408c2a85b01b1736303f9044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of a values in an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of values.  <a href="#a72d7ee25408c2a85b01b1736303f9044">More...</a><br /></td></tr>
<tr class="separator:a72d7ee25408c2a85b01b1736303f9044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15dea3426639a0f8f4a094d8ca09cbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#aa15dea3426639a0f8f4a094d8ca09cbc">hasAllValues</a> (const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; V &gt; &amp;<a class="el" href="classhltypes_1_1_map.html#ac80a66e7e7ee1839b65ad6d0721e3d6f">values</a>) const</td></tr>
<tr class="memdesc:aa15dea3426639a0f8f4a094d8ca09cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of all values.  <a href="#aa15dea3426639a0f8f4a094d8ca09cbc">More...</a><br /></td></tr>
<tr class="separator:aa15dea3426639a0f8f4a094d8ca09cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5bafa1d4c3737f78f8c4ca7c37b541"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#aff5bafa1d4c3737f78f8c4ca7c37b541">hasAllValues</a> (const V <a class="el" href="classhltypes_1_1_map.html#ac80a66e7e7ee1839b65ad6d0721e3d6f">values</a>[], const int count) const</td></tr>
<tr class="memdesc:aff5bafa1d4c3737f78f8c4ca7c37b541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of all values.  <a href="#aff5bafa1d4c3737f78f8c4ca7c37b541">More...</a><br /></td></tr>
<tr class="separator:aff5bafa1d4c3737f78f8c4ca7c37b541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda294135328128f23451c960f1442f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#acda294135328128f23451c960f1442f1">insert</a> (const K &amp;key, const V &amp;value)</td></tr>
<tr class="memdesc:acda294135328128f23451c960f1442f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new pair of key and value into the <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>.  <a href="#acda294135328128f23451c960f1442f1">More...</a><br /></td></tr>
<tr class="separator:acda294135328128f23451c960f1442f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29fd79bc43febb0f83d3440db54770a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ab29fd79bc43febb0f83d3440db54770a">insert</a> (const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;other)</td></tr>
<tr class="memdesc:ab29fd79bc43febb0f83d3440db54770a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all pairs of keys and values from another <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> into this one.  <a href="#ab29fd79bc43febb0f83d3440db54770a">More...</a><br /></td></tr>
<tr class="separator:ab29fd79bc43febb0f83d3440db54770a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583835abfbcb8787e15a56010a725e44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a583835abfbcb8787e15a56010a725e44">inject</a> (const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;other)</td></tr>
<tr class="memdesc:a583835abfbcb8787e15a56010a725e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all pairs of keys and values from another <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> into this one.  <a href="#a583835abfbcb8787e15a56010a725e44">More...</a><br /></td></tr>
<tr class="separator:a583835abfbcb8787e15a56010a725e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceb20f2bcff54c06c453a8945b7ebb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a7ceb20f2bcff54c06c453a8945b7ebb1">removeKey</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a7ceb20f2bcff54c06c453a8945b7ebb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a pair of key and value specified by a key.  <a href="#a7ceb20f2bcff54c06c453a8945b7ebb1">More...</a><br /></td></tr>
<tr class="separator:a7ceb20f2bcff54c06c453a8945b7ebb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa437260cab0985efb3c151470cec4865"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#aa437260cab0985efb3c151470cec4865">removeKeys</a> (const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt; &amp;<a class="el" href="classhltypes_1_1_map.html#aef2642cbf87e2920f0e32fe745335535">keys</a>)</td></tr>
<tr class="memdesc:aa437260cab0985efb3c151470cec4865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all pairs of key and value specified by an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of keys.  <a href="#aa437260cab0985efb3c151470cec4865">More...</a><br /></td></tr>
<tr class="separator:aa437260cab0985efb3c151470cec4865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d429e2046bfa85f863673734fb20a64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a4d429e2046bfa85f863673734fb20a64">removeValue</a> (const V &amp;value)</td></tr>
<tr class="memdesc:a4d429e2046bfa85f863673734fb20a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a pair of key and value specified by a value.  <a href="#a4d429e2046bfa85f863673734fb20a64">More...</a><br /></td></tr>
<tr class="separator:a4d429e2046bfa85f863673734fb20a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a03efbf2679f33af1b6bde4ef5d11e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ad5a03efbf2679f33af1b6bde4ef5d11e">removeValues</a> (const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; V &gt; &amp;<a class="el" href="classhltypes_1_1_map.html#ac80a66e7e7ee1839b65ad6d0721e3d6f">values</a>)</td></tr>
<tr class="memdesc:ad5a03efbf2679f33af1b6bde4ef5d11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all pairs of key and value specified by an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of values.  <a href="#ad5a03efbf2679f33af1b6bde4ef5d11e">More...</a><br /></td></tr>
<tr class="separator:ad5a03efbf2679f33af1b6bde4ef5d11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56c3075ad7a0c35a0cf0f0a0a4b6df8"><td class="memItemLeft" align="right" valign="top">K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#aa56c3075ad7a0c35a0cf0f0a0a4b6df8">random</a> (V *value=NULL) const</td></tr>
<tr class="memdesc:aa56c3075ad7a0c35a0cf0f0a0a4b6df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a random element in <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>.  <a href="#aa56c3075ad7a0c35a0cf0f0a0a4b6df8">More...</a><br /></td></tr>
<tr class="separator:aa56c3075ad7a0c35a0cf0f0a0a4b6df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aee908547eef9c29c9047100fae79af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a6aee908547eef9c29c9047100fae79af">random</a> (int count) const</td></tr>
<tr class="memdesc:a6aee908547eef9c29c9047100fae79af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> of random elements selected from this one.  <a href="#a6aee908547eef9c29c9047100fae79af">More...</a><br /></td></tr>
<tr class="separator:a6aee908547eef9c29c9047100fae79af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeede5d81d481d7596ea568874f169892"><td class="memItemLeft" align="right" valign="top">K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#aeede5d81d481d7596ea568874f169892">removeRandom</a> (V *value=NULL)</td></tr>
<tr class="memdesc:aeede5d81d481d7596ea568874f169892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a random element in <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> and removes it.  <a href="#aeede5d81d481d7596ea568874f169892">More...</a><br /></td></tr>
<tr class="separator:aeede5d81d481d7596ea568874f169892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6030cd0c6a17be224062c72406234546"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a6030cd0c6a17be224062c72406234546">removeRandom</a> (int count)</td></tr>
<tr class="memdesc:a6030cd0c6a17be224062c72406234546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> of random elements selected from this one and removes them.  <a href="#a6030cd0c6a17be224062c72406234546">More...</a><br /></td></tr>
<tr class="separator:a6030cd0c6a17be224062c72406234546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebae1b4b97de276265dab7664229d30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a2ebae1b4b97de276265dab7664229d30">findAll</a> (bool(*conditionFunction)(K const &amp;, V const &amp;)) const</td></tr>
<tr class="memdesc:a2ebae1b4b97de276265dab7664229d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with entries that match the condition.  <a href="#a2ebae1b4b97de276265dab7664229d30">More...</a><br /></td></tr>
<tr class="separator:a2ebae1b4b97de276265dab7664229d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad128627fcd95812d88b49da933838539"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ad128627fcd95812d88b49da933838539">matchesAny</a> (bool(*conditionFunction)(K const &amp;, V const &amp;)) const</td></tr>
<tr class="memdesc:ad128627fcd95812d88b49da933838539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if at least one entry matches the condition.  <a href="#ad128627fcd95812d88b49da933838539">More...</a><br /></td></tr>
<tr class="separator:ad128627fcd95812d88b49da933838539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454fdeec1fb14952ed42ce399bd1d315"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a454fdeec1fb14952ed42ce399bd1d315">matchesAll</a> (bool(*conditionFunction)(K const &amp;, V const &amp;)) const</td></tr>
<tr class="memdesc:a454fdeec1fb14952ed42ce399bd1d315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all entries match the condition.  <a href="#a454fdeec1fb14952ed42ce399bd1d315">More...</a><br /></td></tr>
<tr class="separator:a454fdeec1fb14952ed42ce399bd1d315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31563f9643230295720c502af1b6de2"><td class="memTemplParams" colspan="2">template&lt;typename L , typename S &gt; </td></tr>
<tr class="memitem:ad31563f9643230295720c502af1b6de2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; L, S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ad31563f9643230295720c502af1b6de2">cast</a> () const</td></tr>
<tr class="memdesc:ad31563f9643230295720c502af1b6de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values cast into the type L and S.  <a href="#ad31563f9643230295720c502af1b6de2">More...</a><br /></td></tr>
<tr class="separator:ad31563f9643230295720c502af1b6de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc57ee683b402f3bbb6378f320422f9"><td class="memTemplParams" colspan="2">template&lt;typename L , typename S &gt; </td></tr>
<tr class="memitem:a6cc57ee683b402f3bbb6378f320422f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; L, S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a6cc57ee683b402f3bbb6378f320422f9">dynamicCast</a> (bool includeNulls=false) const</td></tr>
<tr class="memdesc:a6cc57ee683b402f3bbb6378f320422f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values dynamically cast into the type L and S.  <a href="#a6cc57ee683b402f3bbb6378f320422f9">More...</a><br /></td></tr>
<tr class="separator:a6cc57ee683b402f3bbb6378f320422f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd8125d7fc53a7a6e6df3b6d3d3452a"><td class="memTemplParams" colspan="2">template&lt;typename L , typename S &gt; </td></tr>
<tr class="memitem:addd8125d7fc53a7a6e6df3b6d3d3452a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; L, S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#addd8125d7fc53a7a6e6df3b6d3d3452a">dynamicCastKeys</a> () const</td></tr>
<tr class="memdesc:addd8125d7fc53a7a6e6df3b6d3d3452a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values dynamically cast into the type L and non-dynamically into S.  <a href="#addd8125d7fc53a7a6e6df3b6d3d3452a">More...</a><br /></td></tr>
<tr class="separator:addd8125d7fc53a7a6e6df3b6d3d3452a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b120f9d9f7f1eaded2589c770877b0"><td class="memTemplParams" colspan="2">template&lt;typename L , typename S &gt; </td></tr>
<tr class="memitem:ac2b120f9d9f7f1eaded2589c770877b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; L, S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ac2b120f9d9f7f1eaded2589c770877b0">dynamicCastValues</a> (bool includeNulls=false) const</td></tr>
<tr class="memdesc:ac2b120f9d9f7f1eaded2589c770877b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values cast into the type L and dynamically into S.  <a href="#ac2b120f9d9f7f1eaded2589c770877b0">More...</a><br /></td></tr>
<tr class="separator:ac2b120f9d9f7f1eaded2589c770877b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dac464c4ec273b3fe8bc8a95e24acf3"><td class="memItemLeft" align="right" valign="top">V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a6dac464c4ec273b3fe8bc8a95e24acf3">tryGet</a> (K key, V defaultValue) const</td></tr>
<tr class="memdesc:a6dac464c4ec273b3fe8bc8a95e24acf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns value stored at key. In case no value is found, returns the given default value.  <a href="#a6dac464c4ec273b3fe8bc8a95e24acf3">More...</a><br /></td></tr>
<tr class="separator:a6dac464c4ec273b3fe8bc8a95e24acf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd4ff8c636c2ceb7359f758dd514d5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a3cd4ff8c636c2ceb7359f758dd514d5e">operator+=</a> (const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;other)</td></tr>
<tr class="memdesc:a3cd4ff8c636c2ceb7359f758dd514d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as insert.  <a href="#a3cd4ff8c636c2ceb7359f758dd514d5e">More...</a><br /></td></tr>
<tr class="separator:a3cd4ff8c636c2ceb7359f758dd514d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666ce81836de1230e81f8c5108dde590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a666ce81836de1230e81f8c5108dde590">operator+</a> (const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;other) const</td></tr>
<tr class="memdesc:a666ce81836de1230e81f8c5108dde590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two Mapss.  <a href="#a666ce81836de1230e81f8c5108dde590">More...</a><br /></td></tr>
<tr class="separator:a666ce81836de1230e81f8c5108dde590"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename K, typename V&gt;<br />
class hltypes::Map&lt; K, V &gt;</h3>

<p>Encapsulates std::map and adds high level methods. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9734443a4728f65a1dba47a5e57a1cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9734443a4728f65a1dba47a5e57a1cba">&#9670;&nbsp;</a></span>Map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::<a class="el" href="classhltypes_1_1_map.html">Map</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td><a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad31563f9643230295720c502af1b6de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31563f9643230295720c502af1b6de2">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename L , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt;L, S&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values cast into the type L and S. </p>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values cast into the type L and S. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Make sure all keys can be cast into type L and all values into type S. </dd></dl>

</div>
</div>
<a id="a6cc57ee683b402f3bbb6378f320422f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc57ee683b402f3bbb6378f320422f9">&#9670;&nbsp;</a></span>dynamicCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename L , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt;L, S&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::dynamicCast </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeNulls</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values dynamically cast into the type L and S. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">includeNulls</td><td>Whether to include value NULLs that failed to cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values cast into the type L and S. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Be careful not to use this function with non-pointers and classes that don't have virtual functions. </dd></dl>

</div>
</div>
<a id="addd8125d7fc53a7a6e6df3b6d3d3452a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd8125d7fc53a7a6e6df3b6d3d3452a">&#9670;&nbsp;</a></span>dynamicCastKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename L , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt;L, S&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::dynamicCastKeys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values dynamically cast into the type L and non-dynamically into S. </p>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values cast into the type L and S. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If dynamic casting fails, it won't be included in the result. </dd>
<dd>
Be careful not to use this function with non-pointers and classes that don't have virtual functions. </dd></dl>

</div>
</div>
<a id="ac2b120f9d9f7f1eaded2589c770877b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b120f9d9f7f1eaded2589c770877b0">&#9670;&nbsp;</a></span>dynamicCastValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename L , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt;L, S&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::dynamicCastValues </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeNulls</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values cast into the type L and dynamically into S. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">includeNulls</td><td>Whether to include value NULLs that failed to cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values cast into the type L and S. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Be careful not to use this function with non-pointers and classes that don't have virtual functions. </dd></dl>

</div>
</div>
<a id="ad9cafe7cd61219c1824cc1bd40cf2984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9cafe7cd61219c1824cc1bd40cf2984">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two Maps for being equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Another <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if number of keys and values are equal and all pairs of keys and values are equal. </dd></dl>

</div>
</div>
<a id="a2ebae1b4b97de276265dab7664229d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebae1b4b97de276265dab7664229d30">&#9670;&nbsp;</a></span>findAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt;K, V&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::findAll </td>
          <td>(</td>
          <td class="paramtype">bool(*)(K const &amp;, V const &amp;)&#160;</td>
          <td class="paramname"><em>conditionFunction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds and returns new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with entries that match the condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conditionFunction</td><td>Function pointer with condition function that takes a key of type K and a value of type V and returns bool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all matching elements. </dd></dl>

</div>
</div>
<a id="a1229db6753b166a6daec52d6564a4f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1229db6753b166a6daec52d6564a4f0b">&#9670;&nbsp;</a></span>hasAllKeys() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasAllKeys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of all keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td><a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of keys to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all keys are present. </dd></dl>

</div>
</div>
<a id="a6f0c78039113a25701848b6da86aa741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0c78039113a25701848b6da86aa741">&#9670;&nbsp;</a></span>hasAllKeys() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasAllKeys </td>
          <td>(</td>
          <td class="paramtype">const K&#160;</td>
          <td class="paramname"><em>keys</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of all keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>C-type array of keys to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of keys to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all keys are present. </dd></dl>

</div>
</div>
<a id="aa15dea3426639a0f8f4a094d8ca09cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15dea3426639a0f8f4a094d8ca09cbc">&#9670;&nbsp;</a></span>hasAllValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasAllValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of all values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td><a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of values to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all values are present. </dd></dl>

</div>
</div>
<a id="aff5bafa1d4c3737f78f8c4ca7c37b541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5bafa1d4c3737f78f8c4ca7c37b541">&#9670;&nbsp;</a></span>hasAllValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasAllValues </td>
          <td>(</td>
          <td class="paramtype">const V&#160;</td>
          <td class="paramname"><em>values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of all values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>C-type array of values to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of values to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all values are present. </dd></dl>

</div>
</div>
<a id="ae603dc45594ba0bc72ed4f71c0e9d91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae603dc45594ba0bc72ed4f71c0e9d91a">&#9670;&nbsp;</a></span>hasAnyKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasAnyKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of a key within an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td><a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of keys to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any key is present. </dd></dl>

</div>
</div>
<a id="a92d76235e0053e11869cd761f1d13506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d76235e0053e11869cd761f1d13506">&#9670;&nbsp;</a></span>hasAnyKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasAnyKey </td>
          <td>(</td>
          <td class="paramtype">const K&#160;</td>
          <td class="paramname"><em>keys</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of a key within an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>C-type array of keys to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of keys to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any key is present. </dd></dl>

</div>
</div>
<a id="a92ed4d08538d9d4ea1f7ff05af3984ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ed4d08538d9d4ea1f7ff05af3984ba">&#9670;&nbsp;</a></span>hasAnyValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasAnyValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of a values in an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td><a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of values to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any values are present. </dd></dl>

</div>
</div>
<a id="a72d7ee25408c2a85b01b1736303f9044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d7ee25408c2a85b01b1736303f9044">&#9670;&nbsp;</a></span>hasAnyValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasAnyValue </td>
          <td>(</td>
          <td class="paramtype">const V&#160;</td>
          <td class="paramname"><em>values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of a values in an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>C-type array of values to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of values to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any values are present. </dd></dl>

</div>
</div>
<a id="a522ca637176505439a9578e3e5cd5bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522ca637176505439a9578e3e5cd5bbc">&#9670;&nbsp;</a></span>hasKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasKey </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if key is present. </dd></dl>

</div>
</div>
<a id="a21f4ca01ded32016041040a486b3255c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f4ca01ded32016041040a486b3255c">&#9670;&nbsp;</a></span>hasValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasValue </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if value is present. </dd></dl>

</div>
</div>
<a id="a583835abfbcb8787e15a56010a725e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583835abfbcb8787e15a56010a725e44">&#9670;&nbsp;</a></span>inject()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::inject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds all pairs of keys and values from another <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> into this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Another <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Entries with already existing keys will be overwritten. In comparison to insert, this function is doing a barrel roll. </dd></dl>

</div>
</div>
<a id="acda294135328128f23451c960f1442f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda294135328128f23451c960f1442f1">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new pair of key and value into the <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key of the entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value of the entry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab29fd79bc43febb0f83d3440db54770a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29fd79bc43febb0f83d3440db54770a">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds all pairs of keys and values from another <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> into this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Another <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Entries with already existing keys will not be overwritten. </dd></dl>

</div>
</div>
<a id="aa69b25f8ab1c89a7785a4a919975ecc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69b25f8ab1c89a7785a4a919975ecc1">&#9670;&nbsp;</a></span>keyOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::keyOf </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns key of specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value with the given key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Key of specified value. </dd></dl>

</div>
</div>
<a id="aef2642cbf87e2920f0e32fe745335535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2642cbf87e2920f0e32fe745335535">&#9670;&nbsp;</a></span>keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt;K&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all keys. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all keys. </dd></dl>

</div>
</div>
<a id="acd0792aff70ed52424662bb1a3075bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0792aff70ed52424662bb1a3075bdf">&#9670;&nbsp;</a></span>keyValuePairs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt;std::pair&lt;K, V&gt; &gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::keyValuePairs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all key-value pairs. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all key-value pairs. </dd></dl>

</div>
</div>
<a id="aea63d2a46d2d7d63aecd82a66bf15dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea63d2a46d2d7d63aecd82a66bf15dc3">&#9670;&nbsp;</a></span>keyValuePairs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt;std::pair&lt;K, V&gt; &gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::keyValuePairs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all key-value pairs in the same order as the given corresponding keys. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all key-value pairs in the same order as the given corresponding keys. </dd></dl>

</div>
</div>
<a id="a454fdeec1fb14952ed42ce399bd1d315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454fdeec1fb14952ed42ce399bd1d315">&#9670;&nbsp;</a></span>matchesAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::matchesAll </td>
          <td>(</td>
          <td class="paramtype">bool(*)(K const &amp;, V const &amp;)&#160;</td>
          <td class="paramname"><em>conditionFunction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if all entries match the condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conditionFunction</td><td>Function pointer with condition function that takes a key of type K and a value of type V and returns bool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all entries match the condition. </dd></dl>

</div>
</div>
<a id="ad128627fcd95812d88b49da933838539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad128627fcd95812d88b49da933838539">&#9670;&nbsp;</a></span>matchesAny()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::matchesAny </td>
          <td>(</td>
          <td class="paramtype">bool(*)(K const &amp;, V const &amp;)&#160;</td>
          <td class="paramname"><em>conditionFunction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if at least one entry matches the condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conditionFunction</td><td>Function pointer with condition function that takes a key of type K and a value of type V and returns bool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if at least one entry matches the condition. </dd></dl>

</div>
</div>
<a id="a7ec85d9b8fede42be01cc1daab0ece30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec85d9b8fede42be01cc1daab0ece30">&#9670;&nbsp;</a></span>nequals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::nequals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two Maps for being not equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Another <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if number of keys and values are not equal or at least one pair of keys and values is not equal. </dd></dl>

</div>
</div>
<a id="a2b4b4a3e5235eeecd430ef39e94567cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4b4a3e5235eeecd430ef39e94567cd">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as nequals. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhltypes_1_1_map.html#a7ec85d9b8fede42be01cc1daab0ece30" title="Compares the contents of two Maps for being not equal. ">nequals</a> </dd></dl>

</div>
</div>
<a id="ad7fc080e73d7eebcf7e523c51d1d7d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fc080e73d7eebcf7e523c51d1d7d0d">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as key_of. </p>
<dl class="section see"><dt>See also</dt><dd>key_of </dd></dl>

</div>
</div>
<a id="a666ce81836de1230e81f8c5108dde590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666ce81836de1230e81f8c5108dde590">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt;K, V&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two Mapss. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Second <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> to merge with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with elements of second <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> added at the end of first <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Entries with already existing keys in the first map will not be overwritten. </dd></dl>

</div>
</div>
<a id="a3cd4ff8c636c2ceb7359f758dd514d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd4ff8c636c2ceb7359f758dd514d5e">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt;K, V&gt;&amp; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as insert. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhltypes_1_1_map.html#ab29fd79bc43febb0f83d3440db54770a" title="Adds all pairs of keys and values from another Map into this one. ">insert(const Map&lt;K, V&gt;&amp; other)</a> </dd></dl>

</div>
</div>
<a id="a27ace1c4a7f7c12acbe886dddb1ca4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ace1c4a7f7c12acbe886dddb1ca4f3">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as equals. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhltypes_1_1_map.html#ad9cafe7cd61219c1824cc1bd40cf2984" title="Compares the contents of two Maps for being equal. ">equals</a> </dd></dl>

</div>
</div>
<a id="a44f856ce764decaee35b82100aa61302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f856ce764decaee35b82100aa61302">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V&amp; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns value with specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key of the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value with specified key. </dd></dl>

</div>
</div>
<a id="aa56c3075ad7a0c35a0cf0f0a0a4b6df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56c3075ad7a0c35a0cf0f0a0a4b6df8">&#9670;&nbsp;</a></span>random() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::random </td>
          <td>(</td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>value</em> = <code>NULL</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a random element in <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Value of selected random entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random element or NULL if <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> is empty. </dd></dl>

</div>
</div>
<a id="a6aee908547eef9c29c9047100fae79af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aee908547eef9c29c9047100fae79af">&#9670;&nbsp;</a></span>random() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt;K, V&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::random </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> of random elements selected from this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of random elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> of random elements selected from this one. </dd></dl>

</div>
</div>
<a id="a7ceb20f2bcff54c06c453a8945b7ebb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ceb20f2bcff54c06c453a8945b7ebb1">&#9670;&nbsp;</a></span>removeKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::removeKey </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a pair of key and value specified by a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key of the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if key was present and removed. </dd></dl>

</div>
</div>
<a id="aa437260cab0985efb3c151470cec4865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa437260cab0985efb3c151470cec4865">&#9670;&nbsp;</a></span>removeKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::removeKeys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all pairs of key and value specified by an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td><a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>How many keys were removed. </dd></dl>

</div>
</div>
<a id="aeede5d81d481d7596ea568874f169892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeede5d81d481d7596ea568874f169892">&#9670;&nbsp;</a></span>removeRandom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::removeRandom </td>
          <td>(</td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>value</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a random element in <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> and removes it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Value of selected random entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random element or NULL if <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> is empty. </dd></dl>

</div>
</div>
<a id="a6030cd0c6a17be224062c72406234546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6030cd0c6a17be224062c72406234546">&#9670;&nbsp;</a></span>removeRandom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt;K, V&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::removeRandom </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> of random elements selected from this one and removes them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of random elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> of random elements selected from this one. </dd></dl>

</div>
</div>
<a id="a4d429e2046bfa85f863673734fb20a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d429e2046bfa85f863673734fb20a64">&#9670;&nbsp;</a></span>removeValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::removeValue </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a pair of key and value specified by a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value of the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if value was present and removed. </dd></dl>

</div>
</div>
<a id="ad5a03efbf2679f33af1b6bde4ef5d11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a03efbf2679f33af1b6bde4ef5d11e">&#9670;&nbsp;</a></span>removeValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::removeValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all pairs of key and value specified by an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td><a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>How many values were removed. </dd></dl>

</div>
</div>
<a id="a37294bcbb724443f84678a21f3b5e9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37294bcbb724443f84678a21f3b5e9f0">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of values in the <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of values in the <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>. </dd></dl>

</div>
</div>
<a id="a6dac464c4ec273b3fe8bc8a95e24acf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dac464c4ec273b3fe8bc8a95e24acf3">&#9670;&nbsp;</a></span>tryGet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::tryGet </td>
          <td>(</td>
          <td class="paramtype">K&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds and returns value stored at key. In case no value is found, returns the given default value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to retrieve the value of. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to return if key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value stored at key or given default value. </dd></dl>

</div>
</div>
<a id="ac6a8ad251d2ae43665ea522c08663b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a8ad251d2ae43665ea522c08663b73">&#9670;&nbsp;</a></span>valueOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::valueOf </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns value of specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key of the given value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of specified key. </dd></dl>

</div>
</div>
<a id="ac80a66e7e7ee1839b65ad6d0721e3d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80a66e7e7ee1839b65ad6d0721e3d6f">&#9670;&nbsp;</a></span>values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt;V&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all values. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all values. </dd></dl>

</div>
</div>
<a id="aca8faec6d2543aab4f077b814775be58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8faec6d2543aab4f077b814775be58">&#9670;&nbsp;</a></span>values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt;V&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all values in the same order as the given corresponding keys. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all values in the same order as the given corresponding keys. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/hltypes/<a class="el" href="hmap_8h_source.html">hmap.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
