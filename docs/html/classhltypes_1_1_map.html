<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>C++ High Level Types: hltypes::Map&lt; K, V &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C++ High Level Types
   </div>
   <div id="projectbrief">This library provides commonly used high level types and methods for easier and better coding.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>hltypes</b></li><li class="navelem"><a class="el" href="classhltypes_1_1_map.html">Map</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classhltypes_1_1_map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hltypes::Map&lt; K, V &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulates std::map and adds high level methods.  
 <a href="classhltypes_1_1_map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="hmap_8h_source.html">hmap.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for hltypes::Map&lt; K, V &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classhltypes_1_1_map.png" usemap="#hltypes::Map_3C_20K_2C_20V_20_3E_map" alt=""/>
  <map id="hltypes::Map_3C_20K_2C_20V_20_3E_map" name="hltypes::Map&lt; K, V &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a678963c35deca835dbee0a182759e2a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a678963c35deca835dbee0a182759e2a1"></a>
typedef std::map&lt; K, V &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a678963c35deca835dbee0a182759e2a1">iterator_t</a></td></tr>
<tr class="memdesc:a678963c35deca835dbee0a182759e2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type exposure. <br /></td></tr>
<tr class="separator:a678963c35deca835dbee0a182759e2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a57136c1a6cc1d51814b219584331a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12a57136c1a6cc1d51814b219584331a"></a>
typedef std::map&lt; K, V &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a12a57136c1a6cc1d51814b219584331a">const_iterator_t</a></td></tr>
<tr class="memdesc:a12a57136c1a6cc1d51814b219584331a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type exposure. <br /></td></tr>
<tr class="separator:a12a57136c1a6cc1d51814b219584331a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cd5ceed9d307b48cc19e029ee66006"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31cd5ceed9d307b48cc19e029ee66006"></a>
typedef std::vector&lt; K &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a31cd5ceed9d307b48cc19e029ee66006">kiterator_t</a></td></tr>
<tr class="memdesc:a31cd5ceed9d307b48cc19e029ee66006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type exposure. <br /></td></tr>
<tr class="separator:a31cd5ceed9d307b48cc19e029ee66006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bf325b279b5a92a0b0aecd637a6291"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54bf325b279b5a92a0b0aecd637a6291"></a>
typedef std::vector&lt; K &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a54bf325b279b5a92a0b0aecd637a6291">const_kiterator_t</a></td></tr>
<tr class="memdesc:a54bf325b279b5a92a0b0aecd637a6291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type exposure. <br /></td></tr>
<tr class="separator:a54bf325b279b5a92a0b0aecd637a6291"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a38ca7d0a892d3111abe7d0db66470284"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38ca7d0a892d3111abe7d0db66470284"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a38ca7d0a892d3111abe7d0db66470284">Map</a> ()</td></tr>
<tr class="memdesc:a38ca7d0a892d3111abe7d0db66470284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor. <br /></td></tr>
<tr class="separator:a38ca7d0a892d3111abe7d0db66470284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9734443a4728f65a1dba47a5e57a1cba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a9734443a4728f65a1dba47a5e57a1cba">Map</a> (const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;other)</td></tr>
<tr class="memdesc:a9734443a4728f65a1dba47a5e57a1cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a9734443a4728f65a1dba47a5e57a1cba">More...</a><br /></td></tr>
<tr class="separator:a9734443a4728f65a1dba47a5e57a1cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae655dda4f50b5a9cbb80d37a1d6b71f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae655dda4f50b5a9cbb80d37a1d6b71f6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ae655dda4f50b5a9cbb80d37a1d6b71f6">~Map</a> ()</td></tr>
<tr class="memdesc:ae655dda4f50b5a9cbb80d37a1d6b71f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ae655dda4f50b5a9cbb80d37a1d6b71f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f856ce764decaee35b82100aa61302"><td class="memItemLeft" align="right" valign="top">V &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a44f856ce764decaee35b82100aa61302">operator[]</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a44f856ce764decaee35b82100aa61302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns value with specified key.  <a href="#a44f856ce764decaee35b82100aa61302">More...</a><br /></td></tr>
<tr class="separator:a44f856ce764decaee35b82100aa61302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431ad6659a46c52188fba5a998c4477f"><td class="memItemLeft" align="right" valign="top">K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a431ad6659a46c52188fba5a998c4477f">operator()</a> (const V &amp;value) const </td></tr>
<tr class="memdesc:a431ad6659a46c52188fba5a998c4477f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as key_of.  <a href="#a431ad6659a46c52188fba5a998c4477f">More...</a><br /></td></tr>
<tr class="separator:a431ad6659a46c52188fba5a998c4477f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f34e1e3e2ea60544259ad456a97aefd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a7f34e1e3e2ea60544259ad456a97aefd">operator==</a> (const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;other) const </td></tr>
<tr class="memdesc:a7f34e1e3e2ea60544259ad456a97aefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as equals.  <a href="#a7f34e1e3e2ea60544259ad456a97aefd">More...</a><br /></td></tr>
<tr class="separator:a7f34e1e3e2ea60544259ad456a97aefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab522d32a4a7381e677898916d512ec39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ab522d32a4a7381e677898916d512ec39">operator!=</a> (const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;other) const </td></tr>
<tr class="memdesc:ab522d32a4a7381e677898916d512ec39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as nequals.  <a href="#ab522d32a4a7381e677898916d512ec39">More...</a><br /></td></tr>
<tr class="separator:ab522d32a4a7381e677898916d512ec39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b20c8e101f538206c0d3862587813e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ab2b20c8e101f538206c0d3862587813e">size</a> () const </td></tr>
<tr class="memdesc:ab2b20c8e101f538206c0d3862587813e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of values in the <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>.  <a href="#ab2b20c8e101f538206c0d3862587813e">More...</a><br /></td></tr>
<tr class="separator:ab2b20c8e101f538206c0d3862587813e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b739f42501cb63b745ec337d82b5f3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a0b739f42501cb63b745ec337d82b5f3f">keys</a> () const </td></tr>
<tr class="memdesc:a0b739f42501cb63b745ec337d82b5f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all keys.  <a href="#a0b739f42501cb63b745ec337d82b5f3f">More...</a><br /></td></tr>
<tr class="separator:a0b739f42501cb63b745ec337d82b5f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3e6433f2eccc00e8c2f5185bb49daf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#aee3e6433f2eccc00e8c2f5185bb49daf">values</a> () const </td></tr>
<tr class="memdesc:aee3e6433f2eccc00e8c2f5185bb49daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all values.  <a href="#aee3e6433f2eccc00e8c2f5185bb49daf">More...</a><br /></td></tr>
<tr class="separator:aee3e6433f2eccc00e8c2f5185bb49daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39649c35409f746d7ecc665138c5a2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ab39649c35409f746d7ecc665138c5a2e">values</a> (const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt; <a class="el" href="classhltypes_1_1_map.html#a0b739f42501cb63b745ec337d82b5f3f">keys</a>) const </td></tr>
<tr class="memdesc:ab39649c35409f746d7ecc665138c5a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all values in the same order as the given corresponding keys.  <a href="#ab39649c35409f746d7ecc665138c5a2e">More...</a><br /></td></tr>
<tr class="separator:ab39649c35409f746d7ecc665138c5a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc3d7bcd8f2a7fe2bcb7d402c2c749d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; std::pair&lt; K, V &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#afbc3d7bcd8f2a7fe2bcb7d402c2c749d">keyValuePairs</a> () const </td></tr>
<tr class="memdesc:afbc3d7bcd8f2a7fe2bcb7d402c2c749d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all key-value pairs.  <a href="#afbc3d7bcd8f2a7fe2bcb7d402c2c749d">More...</a><br /></td></tr>
<tr class="separator:afbc3d7bcd8f2a7fe2bcb7d402c2c749d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a0e560c111a31ef10b904c4a4af134"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; std::pair&lt; K, V &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a35a0e560c111a31ef10b904c4a4af134">keyValuePairs</a> (const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt; <a class="el" href="classhltypes_1_1_map.html#a0b739f42501cb63b745ec337d82b5f3f">keys</a>) const </td></tr>
<tr class="memdesc:a35a0e560c111a31ef10b904c4a4af134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all key-value pairs in the same order as the given corresponding keys.  <a href="#a35a0e560c111a31ef10b904c4a4af134">More...</a><br /></td></tr>
<tr class="separator:a35a0e560c111a31ef10b904c4a4af134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f1eb94616345edd6fefaab43925b38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ac8f1eb94616345edd6fefaab43925b38">equals</a> (const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;other) const </td></tr>
<tr class="memdesc:ac8f1eb94616345edd6fefaab43925b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two Maps for being equal.  <a href="#ac8f1eb94616345edd6fefaab43925b38">More...</a><br /></td></tr>
<tr class="separator:ac8f1eb94616345edd6fefaab43925b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabf2c4e9f5062edbf1c662598b948d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#aeabf2c4e9f5062edbf1c662598b948d3">nequals</a> (const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;other) const </td></tr>
<tr class="memdesc:aeabf2c4e9f5062edbf1c662598b948d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two Maps for being not equal.  <a href="#aeabf2c4e9f5062edbf1c662598b948d3">More...</a><br /></td></tr>
<tr class="separator:aeabf2c4e9f5062edbf1c662598b948d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9db57e5b6c5301aa58c7af2f48fde5"><td class="memItemLeft" align="right" valign="top">K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#aae9db57e5b6c5301aa58c7af2f48fde5">keyOf</a> (const V &amp;value) const </td></tr>
<tr class="memdesc:aae9db57e5b6c5301aa58c7af2f48fde5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns key of specified value.  <a href="#aae9db57e5b6c5301aa58c7af2f48fde5">More...</a><br /></td></tr>
<tr class="separator:aae9db57e5b6c5301aa58c7af2f48fde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5ac233069db02b0f47b9440761d102"><td class="memItemLeft" align="right" valign="top">V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#aab5ac233069db02b0f47b9440761d102">valueOf</a> (const K &amp;key) const </td></tr>
<tr class="memdesc:aab5ac233069db02b0f47b9440761d102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns value of specified key.  <a href="#aab5ac233069db02b0f47b9440761d102">More...</a><br /></td></tr>
<tr class="separator:aab5ac233069db02b0f47b9440761d102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050c5d8408d8f1a8e71530a07a7b14e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a050c5d8408d8f1a8e71530a07a7b14e9">hasKey</a> (const K &amp;key) const </td></tr>
<tr class="memdesc:a050c5d8408d8f1a8e71530a07a7b14e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of a key.  <a href="#a050c5d8408d8f1a8e71530a07a7b14e9">More...</a><br /></td></tr>
<tr class="separator:a050c5d8408d8f1a8e71530a07a7b14e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0143364214b48c8dcb091a727bad578f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a0143364214b48c8dcb091a727bad578f">hasAnyKey</a> (const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt; &amp;<a class="el" href="classhltypes_1_1_map.html#a0b739f42501cb63b745ec337d82b5f3f">keys</a>) const </td></tr>
<tr class="memdesc:a0143364214b48c8dcb091a727bad578f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of a key within an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of keys.  <a href="#a0143364214b48c8dcb091a727bad578f">More...</a><br /></td></tr>
<tr class="separator:a0143364214b48c8dcb091a727bad578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc867acfb8ce196a981d02f2d70dcb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a1bc867acfb8ce196a981d02f2d70dcb5">hasAnyKey</a> (const K <a class="el" href="classhltypes_1_1_map.html#a0b739f42501cb63b745ec337d82b5f3f">keys</a>[], const int count) const </td></tr>
<tr class="memdesc:a1bc867acfb8ce196a981d02f2d70dcb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of a key within an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of keys.  <a href="#a1bc867acfb8ce196a981d02f2d70dcb5">More...</a><br /></td></tr>
<tr class="separator:a1bc867acfb8ce196a981d02f2d70dcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66c8af5b1b4110fcdc79b665a00d039"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ae66c8af5b1b4110fcdc79b665a00d039">hasAllKeys</a> (const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt; &amp;<a class="el" href="classhltypes_1_1_map.html#a0b739f42501cb63b745ec337d82b5f3f">keys</a>) const </td></tr>
<tr class="memdesc:ae66c8af5b1b4110fcdc79b665a00d039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of all keys.  <a href="#ae66c8af5b1b4110fcdc79b665a00d039">More...</a><br /></td></tr>
<tr class="separator:ae66c8af5b1b4110fcdc79b665a00d039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2907b33339a9cc8b42068c91c729a2f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a2907b33339a9cc8b42068c91c729a2f0">hasAllKeys</a> (const K <a class="el" href="classhltypes_1_1_map.html#a0b739f42501cb63b745ec337d82b5f3f">keys</a>[], const int count) const </td></tr>
<tr class="memdesc:a2907b33339a9cc8b42068c91c729a2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of all keys.  <a href="#a2907b33339a9cc8b42068c91c729a2f0">More...</a><br /></td></tr>
<tr class="separator:a2907b33339a9cc8b42068c91c729a2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291a508418c6e86484023005107537de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a291a508418c6e86484023005107537de">hasValue</a> (const V &amp;value) const </td></tr>
<tr class="memdesc:a291a508418c6e86484023005107537de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of a value.  <a href="#a291a508418c6e86484023005107537de">More...</a><br /></td></tr>
<tr class="separator:a291a508418c6e86484023005107537de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dfe56ea921ef2877e464ac11ac4782"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a80dfe56ea921ef2877e464ac11ac4782">hasAnyValue</a> (const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; V &gt; &amp;<a class="el" href="classhltypes_1_1_map.html#aee3e6433f2eccc00e8c2f5185bb49daf">values</a>) const </td></tr>
<tr class="memdesc:a80dfe56ea921ef2877e464ac11ac4782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of a values in an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of values.  <a href="#a80dfe56ea921ef2877e464ac11ac4782">More...</a><br /></td></tr>
<tr class="separator:a80dfe56ea921ef2877e464ac11ac4782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f20fbf7e5a6ebcbf048bb33b7d43906"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a1f20fbf7e5a6ebcbf048bb33b7d43906">hasAnyValue</a> (const V <a class="el" href="classhltypes_1_1_map.html#aee3e6433f2eccc00e8c2f5185bb49daf">values</a>[], const int count) const </td></tr>
<tr class="memdesc:a1f20fbf7e5a6ebcbf048bb33b7d43906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of a values in an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of values.  <a href="#a1f20fbf7e5a6ebcbf048bb33b7d43906">More...</a><br /></td></tr>
<tr class="separator:a1f20fbf7e5a6ebcbf048bb33b7d43906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a991eeb160976546ab45e774bd79f92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a0a991eeb160976546ab45e774bd79f92">hasAllValues</a> (const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; V &gt; &amp;<a class="el" href="classhltypes_1_1_map.html#aee3e6433f2eccc00e8c2f5185bb49daf">values</a>) const </td></tr>
<tr class="memdesc:a0a991eeb160976546ab45e774bd79f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of all values.  <a href="#a0a991eeb160976546ab45e774bd79f92">More...</a><br /></td></tr>
<tr class="separator:a0a991eeb160976546ab45e774bd79f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27e90f3155cffd366198678beda0cc9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ac27e90f3155cffd366198678beda0cc9">hasAllValues</a> (const V <a class="el" href="classhltypes_1_1_map.html#aee3e6433f2eccc00e8c2f5185bb49daf">values</a>[], const int count) const </td></tr>
<tr class="memdesc:ac27e90f3155cffd366198678beda0cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for existence of all values.  <a href="#ac27e90f3155cffd366198678beda0cc9">More...</a><br /></td></tr>
<tr class="separator:ac27e90f3155cffd366198678beda0cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda294135328128f23451c960f1442f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#acda294135328128f23451c960f1442f1">insert</a> (const K &amp;key, const V &amp;value)</td></tr>
<tr class="memdesc:acda294135328128f23451c960f1442f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new pair of key and value into the <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>.  <a href="#acda294135328128f23451c960f1442f1">More...</a><br /></td></tr>
<tr class="separator:acda294135328128f23451c960f1442f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29fd79bc43febb0f83d3440db54770a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ab29fd79bc43febb0f83d3440db54770a">insert</a> (const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;other)</td></tr>
<tr class="memdesc:ab29fd79bc43febb0f83d3440db54770a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all pairs of keys and values from another <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> into this one.  <a href="#ab29fd79bc43febb0f83d3440db54770a">More...</a><br /></td></tr>
<tr class="separator:ab29fd79bc43febb0f83d3440db54770a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583835abfbcb8787e15a56010a725e44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a583835abfbcb8787e15a56010a725e44">inject</a> (const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;other)</td></tr>
<tr class="memdesc:a583835abfbcb8787e15a56010a725e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all pairs of keys and values from another <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> into this one.  <a href="#a583835abfbcb8787e15a56010a725e44">More...</a><br /></td></tr>
<tr class="separator:a583835abfbcb8787e15a56010a725e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceb20f2bcff54c06c453a8945b7ebb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a7ceb20f2bcff54c06c453a8945b7ebb1">removeKey</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a7ceb20f2bcff54c06c453a8945b7ebb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a pair of key and value specified by a key.  <a href="#a7ceb20f2bcff54c06c453a8945b7ebb1">More...</a><br /></td></tr>
<tr class="separator:a7ceb20f2bcff54c06c453a8945b7ebb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa437260cab0985efb3c151470cec4865"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#aa437260cab0985efb3c151470cec4865">removeKeys</a> (const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt; &amp;<a class="el" href="classhltypes_1_1_map.html#a0b739f42501cb63b745ec337d82b5f3f">keys</a>)</td></tr>
<tr class="memdesc:aa437260cab0985efb3c151470cec4865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all pairs of key and value specified by an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of keys.  <a href="#aa437260cab0985efb3c151470cec4865">More...</a><br /></td></tr>
<tr class="separator:aa437260cab0985efb3c151470cec4865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d429e2046bfa85f863673734fb20a64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a4d429e2046bfa85f863673734fb20a64">removeValue</a> (const V &amp;value)</td></tr>
<tr class="memdesc:a4d429e2046bfa85f863673734fb20a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a pair of key and value specified by a value.  <a href="#a4d429e2046bfa85f863673734fb20a64">More...</a><br /></td></tr>
<tr class="separator:a4d429e2046bfa85f863673734fb20a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a03efbf2679f33af1b6bde4ef5d11e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ad5a03efbf2679f33af1b6bde4ef5d11e">removeValues</a> (const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; V &gt; &amp;<a class="el" href="classhltypes_1_1_map.html#aee3e6433f2eccc00e8c2f5185bb49daf">values</a>)</td></tr>
<tr class="memdesc:ad5a03efbf2679f33af1b6bde4ef5d11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all pairs of key and value specified by an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of values.  <a href="#ad5a03efbf2679f33af1b6bde4ef5d11e">More...</a><br /></td></tr>
<tr class="separator:ad5a03efbf2679f33af1b6bde4ef5d11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd659b1fa9e0f7d108897ecc82831e1"><td class="memItemLeft" align="right" valign="top">K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a7fd659b1fa9e0f7d108897ecc82831e1">random</a> (V *value=NULL) const </td></tr>
<tr class="memdesc:a7fd659b1fa9e0f7d108897ecc82831e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a random element in <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>.  <a href="#a7fd659b1fa9e0f7d108897ecc82831e1">More...</a><br /></td></tr>
<tr class="separator:a7fd659b1fa9e0f7d108897ecc82831e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b02f286b856122bf005b76b62af8d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a39b02f286b856122bf005b76b62af8d7">random</a> (int count) const </td></tr>
<tr class="memdesc:a39b02f286b856122bf005b76b62af8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> of random elements selected from this one.  <a href="#a39b02f286b856122bf005b76b62af8d7">More...</a><br /></td></tr>
<tr class="separator:a39b02f286b856122bf005b76b62af8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeede5d81d481d7596ea568874f169892"><td class="memItemLeft" align="right" valign="top">K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#aeede5d81d481d7596ea568874f169892">removeRandom</a> (V *value=NULL)</td></tr>
<tr class="memdesc:aeede5d81d481d7596ea568874f169892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a random element in <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> and removes it.  <a href="#aeede5d81d481d7596ea568874f169892">More...</a><br /></td></tr>
<tr class="separator:aeede5d81d481d7596ea568874f169892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6030cd0c6a17be224062c72406234546"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a6030cd0c6a17be224062c72406234546">removeRandom</a> (int count)</td></tr>
<tr class="memdesc:a6030cd0c6a17be224062c72406234546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> of random elements selected from this one and removes them.  <a href="#a6030cd0c6a17be224062c72406234546">More...</a><br /></td></tr>
<tr class="separator:a6030cd0c6a17be224062c72406234546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38af28e3199de232545919f4cd5953b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a38af28e3199de232545919f4cd5953b3">findAll</a> (bool(*conditionFunction)(K, V)) const </td></tr>
<tr class="memdesc:a38af28e3199de232545919f4cd5953b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with entries that match the condition.  <a href="#a38af28e3199de232545919f4cd5953b3">More...</a><br /></td></tr>
<tr class="separator:a38af28e3199de232545919f4cd5953b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc626dad59a9fea795412a08677ef38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a0cc626dad59a9fea795412a08677ef38">matchesAny</a> (bool(*conditionFunction)(K, V)) const </td></tr>
<tr class="memdesc:a0cc626dad59a9fea795412a08677ef38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if at least one entry matches the condition.  <a href="#a0cc626dad59a9fea795412a08677ef38">More...</a><br /></td></tr>
<tr class="separator:a0cc626dad59a9fea795412a08677ef38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af953691c6ff5e25f9fd8bc7e5baccb8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#af953691c6ff5e25f9fd8bc7e5baccb8a">matchesAll</a> (bool(*conditionFunction)(K, V)) const </td></tr>
<tr class="memdesc:af953691c6ff5e25f9fd8bc7e5baccb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all entries match the condition.  <a href="#af953691c6ff5e25f9fd8bc7e5baccb8a">More...</a><br /></td></tr>
<tr class="separator:af953691c6ff5e25f9fd8bc7e5baccb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cda3695322bdc53757178d39fdd7629"><td class="memTemplParams" colspan="2">template&lt;typename L , typename S &gt; </td></tr>
<tr class="memitem:a2cda3695322bdc53757178d39fdd7629"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; L, S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a2cda3695322bdc53757178d39fdd7629">cast</a> () const </td></tr>
<tr class="memdesc:a2cda3695322bdc53757178d39fdd7629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values cast into the type L and S.  <a href="#a2cda3695322bdc53757178d39fdd7629">More...</a><br /></td></tr>
<tr class="separator:a2cda3695322bdc53757178d39fdd7629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a001576cc03db34c29261d294c23ee"><td class="memTemplParams" colspan="2">template&lt;typename L , typename S &gt; </td></tr>
<tr class="memitem:a97a001576cc03db34c29261d294c23ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; L, S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a97a001576cc03db34c29261d294c23ee">dynamicCast</a> (bool includeNulls=false) const </td></tr>
<tr class="memdesc:a97a001576cc03db34c29261d294c23ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values dynamically cast into the type L and S.  <a href="#a97a001576cc03db34c29261d294c23ee">More...</a><br /></td></tr>
<tr class="separator:a97a001576cc03db34c29261d294c23ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9baafe91ec6c80a3f7f76f61b4ad734"><td class="memTemplParams" colspan="2">template&lt;typename L , typename S &gt; </td></tr>
<tr class="memitem:ad9baafe91ec6c80a3f7f76f61b4ad734"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; L, S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#ad9baafe91ec6c80a3f7f76f61b4ad734">dynamicCastKeys</a> () const </td></tr>
<tr class="memdesc:ad9baafe91ec6c80a3f7f76f61b4ad734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values dynamically cast into the type L and non-dynamically into S.  <a href="#ad9baafe91ec6c80a3f7f76f61b4ad734">More...</a><br /></td></tr>
<tr class="separator:ad9baafe91ec6c80a3f7f76f61b4ad734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf576d273c97c6a66ff4bec70d37b0f3"><td class="memTemplParams" colspan="2">template&lt;typename L , typename S &gt; </td></tr>
<tr class="memitem:abf576d273c97c6a66ff4bec70d37b0f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; L, S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#abf576d273c97c6a66ff4bec70d37b0f3">dynamicCastValues</a> (bool includeNulls=false) const </td></tr>
<tr class="memdesc:abf576d273c97c6a66ff4bec70d37b0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values cast into the type L and dynamically into S.  <a href="#abf576d273c97c6a66ff4bec70d37b0f3">More...</a><br /></td></tr>
<tr class="separator:abf576d273c97c6a66ff4bec70d37b0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad235ba8d97168b1c0eb4ee314c8f679"><td class="memItemLeft" align="right" valign="top">V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#aad235ba8d97168b1c0eb4ee314c8f679">tryGet</a> (K key, V defaultValue) const </td></tr>
<tr class="memdesc:aad235ba8d97168b1c0eb4ee314c8f679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and returns value stored at key. In case no value is found, returns the given default value.  <a href="#aad235ba8d97168b1c0eb4ee314c8f679">More...</a><br /></td></tr>
<tr class="separator:aad235ba8d97168b1c0eb4ee314c8f679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd4ff8c636c2ceb7359f758dd514d5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a3cd4ff8c636c2ceb7359f758dd514d5e">operator+=</a> (const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;other)</td></tr>
<tr class="memdesc:a3cd4ff8c636c2ceb7359f758dd514d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as insert.  <a href="#a3cd4ff8c636c2ceb7359f758dd514d5e">More...</a><br /></td></tr>
<tr class="separator:a3cd4ff8c636c2ceb7359f758dd514d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867eb93de7ff271a8f2d2e5a97a5630b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhltypes_1_1_map.html#a867eb93de7ff271a8f2d2e5a97a5630b">operator+</a> (const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;other) const </td></tr>
<tr class="memdesc:a867eb93de7ff271a8f2d2e5a97a5630b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two Mapss.  <a href="#a867eb93de7ff271a8f2d2e5a97a5630b">More...</a><br /></td></tr>
<tr class="separator:a867eb93de7ff271a8f2d2e5a97a5630b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename K, typename V&gt;<br />
class hltypes::Map&lt; K, V &gt;</h3>

<p>Encapsulates std::map and adds high level methods. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9734443a4728f65a1dba47a5e57a1cba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::<a class="el" href="classhltypes_1_1_map.html">Map</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td><a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2cda3695322bdc53757178d39fdd7629"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename L , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt;L, S&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values cast into the type L and S. </p>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values cast into the type L and S. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Make sure all keys can be cast into type L and all values into type S. </dd></dl>

</div>
</div>
<a class="anchor" id="a97a001576cc03db34c29261d294c23ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename L , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt;L, S&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::dynamicCast </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeNulls</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values dynamically cast into the type L and S. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">includeNulls</td><td>Whether to include value NULLs that failed to cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values cast into the type L and S. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Be careful not to use this function with non-pointers and classes that don't have virtual functions. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9baafe91ec6c80a3f7f76f61b4ad734"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename L , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt;L, S&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::dynamicCastKeys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values dynamically cast into the type L and non-dynamically into S. </p>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values cast into the type L and S. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If dynamic casting fails, it won't be included in the result. </dd>
<dd>
Be careful not to use this function with non-pointers and classes that don't have virtual functions. </dd></dl>

</div>
</div>
<a class="anchor" id="abf576d273c97c6a66ff4bec70d37b0f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename L , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt;L, S&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::dynamicCastValues </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeNulls</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values cast into the type L and dynamically into S. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">includeNulls</td><td>Whether to include value NULLs that failed to cast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all keys and values cast into the type L and S. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Be careful not to use this function with non-pointers and classes that don't have virtual functions. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8f1eb94616345edd6fefaab43925b38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two Maps for being equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Another <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if number of keys and values are equal and all pairs of keys and values are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a38af28e3199de232545919f4cd5953b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt;K, V&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::findAll </td>
          <td>(</td>
          <td class="paramtype">bool(*)(K, V)&#160;</td>
          <td class="paramname"><em>conditionFunction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds and returns new <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with entries that match the condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conditionFunction</td><td>Function pointer with condition function that takes a key of type K and a value of type V and returns bool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with all matching elements. </dd></dl>

</div>
</div>
<a class="anchor" id="ae66c8af5b1b4110fcdc79b665a00d039"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasAllKeys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of all keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td><a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of keys to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all keys are present. </dd></dl>

</div>
</div>
<a class="anchor" id="a2907b33339a9cc8b42068c91c729a2f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasAllKeys </td>
          <td>(</td>
          <td class="paramtype">const K&#160;</td>
          <td class="paramname"><em>keys</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of all keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>C-type array of keys to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of keys to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all keys are present. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a991eeb160976546ab45e774bd79f92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasAllValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of all values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td><a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of values to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all values are present. </dd></dl>

</div>
</div>
<a class="anchor" id="ac27e90f3155cffd366198678beda0cc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasAllValues </td>
          <td>(</td>
          <td class="paramtype">const V&#160;</td>
          <td class="paramname"><em>values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of all values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>C-type array of values to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of values to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all values are present. </dd></dl>

</div>
</div>
<a class="anchor" id="a0143364214b48c8dcb091a727bad578f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasAnyKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of a key within an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td><a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of keys to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any key is present. </dd></dl>

</div>
</div>
<a class="anchor" id="a1bc867acfb8ce196a981d02f2d70dcb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasAnyKey </td>
          <td>(</td>
          <td class="paramtype">const K&#160;</td>
          <td class="paramname"><em>keys</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of a key within an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>C-type array of keys to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of keys to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any key is present. </dd></dl>

</div>
</div>
<a class="anchor" id="a80dfe56ea921ef2877e464ac11ac4782"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasAnyValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of a values in an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td><a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of values to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any values are present. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f20fbf7e5a6ebcbf048bb33b7d43906"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasAnyValue </td>
          <td>(</td>
          <td class="paramtype">const V&#160;</td>
          <td class="paramname"><em>values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of a values in an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>C-type array of values to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of values to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any values are present. </dd></dl>

</div>
</div>
<a class="anchor" id="a050c5d8408d8f1a8e71530a07a7b14e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasKey </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if key is present. </dd></dl>

</div>
</div>
<a class="anchor" id="a291a508418c6e86484023005107537de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::hasValue </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for existence of a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if value is present. </dd></dl>

</div>
</div>
<a class="anchor" id="a583835abfbcb8787e15a56010a725e44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::inject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds all pairs of keys and values from another <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> into this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Another <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Entries with already existing keys will be overwritten. In comparison to insert, this function is doing a barrel roll. </dd></dl>

</div>
</div>
<a class="anchor" id="acda294135328128f23451c960f1442f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new pair of key and value into the <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key of the entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value of the entry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab29fd79bc43febb0f83d3440db54770a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds all pairs of keys and values from another <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> into this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Another <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Entries with already existing keys will not be overwritten. </dd></dl>

</div>
</div>
<a class="anchor" id="aae9db57e5b6c5301aa58c7af2f48fde5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::keyOf </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns key of specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value with the given key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Key of specified value. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b739f42501cb63b745ec337d82b5f3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt;K&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all keys. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all keys. </dd></dl>

</div>
</div>
<a class="anchor" id="afbc3d7bcd8f2a7fe2bcb7d402c2c749d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt;std::pair&lt;K, V&gt; &gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::keyValuePairs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all key-value pairs. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all key-value pairs. </dd></dl>

</div>
</div>
<a class="anchor" id="a35a0e560c111a31ef10b904c4a4af134"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt;std::pair&lt;K, V&gt; &gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::keyValuePairs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all key-value pairs in the same order as the given corresponding keys. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all key-value pairs in the same order as the given corresponding keys. </dd></dl>

</div>
</div>
<a class="anchor" id="af953691c6ff5e25f9fd8bc7e5baccb8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::matchesAll </td>
          <td>(</td>
          <td class="paramtype">bool(*)(K, V)&#160;</td>
          <td class="paramname"><em>conditionFunction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if all entries match the condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conditionFunction</td><td>Function pointer with condition function that takes a key of type K and a value of type V and returns bool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all entries match the condition. </dd></dl>

</div>
</div>
<a class="anchor" id="a0cc626dad59a9fea795412a08677ef38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::matchesAny </td>
          <td>(</td>
          <td class="paramtype">bool(*)(K, V)&#160;</td>
          <td class="paramname"><em>conditionFunction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if at least one entry matches the condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conditionFunction</td><td>Function pointer with condition function that takes a key of type K and a value of type V and returns bool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if at least one entry matches the condition. </dd></dl>

</div>
</div>
<a class="anchor" id="aeabf2c4e9f5062edbf1c662598b948d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::nequals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two Maps for being not equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Another <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if number of keys and values are not equal or at least one pair of keys and values is not equal. </dd></dl>

</div>
</div>
<a class="anchor" id="ab522d32a4a7381e677898916d512ec39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as nequals. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhltypes_1_1_map.html#aeabf2c4e9f5062edbf1c662598b948d3" title="Compares the contents of two Maps for being not equal. ">nequals</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a431ad6659a46c52188fba5a998c4477f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as key_of. </p>
<dl class="section see"><dt>See also</dt><dd>key_of </dd></dl>

</div>
</div>
<a class="anchor" id="a867eb93de7ff271a8f2d2e5a97a5630b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt;K, V&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two Mapss. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Second <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> to merge with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> with elements of second <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> added at the end of first <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Entries with already existing keys in the first map will not be overwritten. </dd></dl>

</div>
</div>
<a class="anchor" id="a3cd4ff8c636c2ceb7359f758dd514d5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt;K, V&gt;&amp; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as insert. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhltypes_1_1_map.html#ab29fd79bc43febb0f83d3440db54770a" title="Adds all pairs of keys and values from another Map into this one. ">insert(const Map&lt;K, V&gt;&amp; other)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7f34e1e3e2ea60544259ad456a97aefd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as equals. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhltypes_1_1_map.html#ac8f1eb94616345edd6fefaab43925b38" title="Compares the contents of two Maps for being equal. ">equals</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a44f856ce764decaee35b82100aa61302"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V&amp; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns value with specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key of the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value with specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="a7fd659b1fa9e0f7d108897ecc82831e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::random </td>
          <td>(</td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>value</em> = <code>NULL</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a random element in <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Value of selected random entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random element or NULL if <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a39b02f286b856122bf005b76b62af8d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt;K, V&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::random </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> of random elements selected from this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of random elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> of random elements selected from this one. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ceb20f2bcff54c06c453a8945b7ebb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::removeKey </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a pair of key and value specified by a key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key of the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if key was present and removed. </dd></dl>

</div>
</div>
<a class="anchor" id="aa437260cab0985efb3c151470cec4865"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::removeKeys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all pairs of key and value specified by an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td><a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>How many keys were removed. </dd></dl>

</div>
</div>
<a class="anchor" id="aeede5d81d481d7596ea568874f169892"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::removeRandom </td>
          <td>(</td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>value</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a random element in <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> and removes it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Value of selected random entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Random element or NULL if <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a6030cd0c6a17be224062c72406234546"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_map.html">Map</a>&lt;K, V&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::removeRandom </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> of random elements selected from this one and removes them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of random elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a> of random elements selected from this one. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d429e2046bfa85f863673734fb20a64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::removeValue </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a pair of key and value specified by a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value of the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if value was present and removed. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5a03efbf2679f33af1b6bde4ef5d11e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::removeValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all pairs of key and value specified by an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td><a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>How many values were removed. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2b20c8e101f538206c0d3862587813e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of values in the <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of values in the <a class="el" href="classhltypes_1_1_map.html" title="Encapsulates std::map and adds high level methods. ">Map</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aad235ba8d97168b1c0eb4ee314c8f679"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::tryGet </td>
          <td>(</td>
          <td class="paramtype">K&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds and returns value stored at key. In case no value is found, returns the given default value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to retrieve the value of. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to return if key does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value stored at key or given default value. </dd></dl>

</div>
</div>
<a class="anchor" id="aab5ac233069db02b0f47b9440761d102"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::valueOf </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns value of specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key of the given value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="aee3e6433f2eccc00e8c2f5185bb49daf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt;V&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all values. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all values. </dd></dl>

</div>
</div>
<a class="anchor" id="ab39649c35409f746d7ecc665138c5a2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhltypes_1_1_array.html">Array</a>&lt;V&gt; <a class="el" href="classhltypes_1_1_map.html">hltypes::Map</a>&lt; K, V &gt;::values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhltypes_1_1_array.html">Array</a>&lt; K &gt;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all values in the same order as the given corresponding keys. </p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classhltypes_1_1_array.html" title="Encapsulates std::vector and adds high level methods. ">Array</a> with all values in the same order as the given corresponding keys. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/hltypes/<a class="el" href="hmap_8h_source.html">hmap.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 3 2016 12:41:04 for C++ High Level Types by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
